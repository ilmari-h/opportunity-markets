/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  type ParsedAddMarketOptionInstruction,
  type ParsedBuyConvictionMarketSharesCallbackInstruction,
  type ParsedBuyConvictionMarketSharesCompDefInstruction,
  type ParsedBuyMarketSharesInstruction,
  type ParsedCalculateVoteTokenBalanceCallbackInstruction,
  type ParsedCalculateVoteTokenBalanceCompDefInstruction,
  type ParsedCreateMarketInstruction,
  type ParsedInitMarketSharesCallbackInstruction,
  type ParsedInitMarketSharesCompDefInstruction,
  type ParsedInitVoteTokenAccountCallbackInstruction,
  type ParsedInitVoteTokenAccountCompDefInstruction,
  type ParsedInitVoteTokenAccountInstruction,
  type ParsedMintVoteTokensInstruction,
  type ParsedOpenMarketInstruction,
} from "../instructions";

export const CONVICTION_MARKET_PROGRAM_ADDRESS =
  "BgtctFuJh2C2dhRQKcz4yrKvYqPrztMJPiEiQdshwUpG" as Address<"BgtctFuJh2C2dhRQKcz4yrKvYqPrztMJPiEiQdshwUpG">;

export enum ConvictionMarketAccount {
  ArciumSignerAccount,
  ClockAccount,
  Cluster,
  ComputationDefinitionAccount,
  ConvictionMarket,
  ConvictionMarketOption,
  FeePool,
  MXEAccount,
  VoteTokenAccount,
}

export function identifyConvictionMarketAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): ConvictionMarketAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([214, 157, 122, 114, 117, 44, 214, 74]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.ArciumSignerAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([152, 171, 158, 195, 75, 61, 51, 8]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.ClockAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([236, 225, 118, 228, 173, 106, 18, 60]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.Cluster;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([245, 176, 217, 221, 253, 104, 172, 200]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.ComputationDefinitionAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([101, 17, 220, 86, 60, 255, 113, 49]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.ConvictionMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([114, 182, 182, 207, 158, 142, 54, 185]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.ConvictionMarketOption;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([172, 38, 77, 146, 148, 5, 51, 242]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.FeePool;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([103, 26, 85, 250, 179, 159, 17, 117]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.MXEAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([147, 20, 17, 210, 187, 123, 96, 22]),
      ),
      0,
    )
  ) {
    return ConvictionMarketAccount.VoteTokenAccount;
  }
  throw new Error(
    "The provided account could not be identified as a convictionMarket account.",
  );
}

export enum ConvictionMarketInstruction {
  AddMarketOption,
  BuyConvictionMarketSharesCallback,
  BuyConvictionMarketSharesCompDef,
  BuyMarketShares,
  CalculateVoteTokenBalanceCallback,
  CalculateVoteTokenBalanceCompDef,
  CreateMarket,
  InitMarketSharesCallback,
  InitMarketSharesCompDef,
  InitVoteTokenAccount,
  InitVoteTokenAccountCallback,
  InitVoteTokenAccountCompDef,
  MintVoteTokens,
  OpenMarket,
}

export function identifyConvictionMarketInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): ConvictionMarketInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([76, 189, 93, 144, 50, 229, 250, 116]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.AddMarketOption;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([57, 180, 169, 101, 215, 97, 225, 27]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.BuyConvictionMarketSharesCallback;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([191, 217, 170, 121, 205, 226, 209, 141]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.BuyConvictionMarketSharesCompDef;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([158, 98, 207, 246, 101, 20, 88, 96]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.BuyMarketShares;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([49, 88, 54, 222, 95, 192, 122, 254]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.CalculateVoteTokenBalanceCallback;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([170, 198, 190, 232, 101, 88, 227, 170]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.CalculateVoteTokenBalanceCompDef;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([103, 226, 97, 235, 200, 188, 251, 254]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.CreateMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([249, 83, 52, 51, 57, 57, 87, 218]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.InitMarketSharesCallback;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([64, 74, 81, 33, 11, 137, 110, 200]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.InitMarketSharesCompDef;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([101, 189, 10, 58, 87, 35, 49, 163]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.InitVoteTokenAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([188, 138, 87, 71, 58, 184, 254, 145]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.InitVoteTokenAccountCallback;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([28, 150, 158, 22, 121, 96, 65, 172]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.InitVoteTokenAccountCompDef;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([131, 125, 39, 240, 75, 196, 200, 187]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.MintVoteTokens;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([116, 19, 123, 75, 217, 244, 69, 44]),
      ),
      0,
    )
  ) {
    return ConvictionMarketInstruction.OpenMarket;
  }
  throw new Error(
    "The provided instruction could not be identified as a convictionMarket instruction.",
  );
}

export type ParsedConvictionMarketInstruction<
  TProgram extends string = "BgtctFuJh2C2dhRQKcz4yrKvYqPrztMJPiEiQdshwUpG",
> =
  | ({
      instructionType: ConvictionMarketInstruction.AddMarketOption;
    } & ParsedAddMarketOptionInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.BuyConvictionMarketSharesCallback;
    } & ParsedBuyConvictionMarketSharesCallbackInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.BuyConvictionMarketSharesCompDef;
    } & ParsedBuyConvictionMarketSharesCompDefInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.BuyMarketShares;
    } & ParsedBuyMarketSharesInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.CalculateVoteTokenBalanceCallback;
    } & ParsedCalculateVoteTokenBalanceCallbackInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.CalculateVoteTokenBalanceCompDef;
    } & ParsedCalculateVoteTokenBalanceCompDefInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.CreateMarket;
    } & ParsedCreateMarketInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.InitMarketSharesCallback;
    } & ParsedInitMarketSharesCallbackInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.InitMarketSharesCompDef;
    } & ParsedInitMarketSharesCompDefInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.InitVoteTokenAccount;
    } & ParsedInitVoteTokenAccountInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.InitVoteTokenAccountCallback;
    } & ParsedInitVoteTokenAccountCallbackInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.InitVoteTokenAccountCompDef;
    } & ParsedInitVoteTokenAccountCompDefInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.MintVoteTokens;
    } & ParsedMintVoteTokensInstruction<TProgram>)
  | ({
      instructionType: ConvictionMarketInstruction.OpenMarket;
    } & ParsedOpenMarketInstruction<TProgram>);
